package hs.jfx.eventstream.api;

import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

import javafx.beans.value.ObservableValue;

/**
 * A sequence of events supporting aggregate operations. The values
 * emitted from this stream are never {@code null} and always a direct
 * result from an event occuring in the source of this stream.<p>
 *
 * Subscribers will receive events only when they occur. If no events
 * occur it is therefore possible that a subscription will never receive
 * an event.<p>
 *
 * This is a lazy stream, which means that it only observes its source
 * when it has observers of its own. When there are no subscribers,
 * this stream stop observing its source immediately.
 *
 * @param <T> the type of events the stream emits
 */
public interface EventStream<T> extends ObservableStream<T> {

  /**
   * Returns an {@link EventStream}, using this stream as its source,
   * which only emits values matching the given predicate.<p>
   *
   * @param predicate a {@link Predicate} which values must match to be emitted, cannot be null
   * @return an {@link EventStream} which only emits values matching the given predicate, never null
   */
  EventStream<T> filter(Predicate<? super T> predicate);

  /**
   * Returns an {@link EventStream} which emits the same values as this stream and,
   * each time this stream emits a value, calls the given {@code sideEffect}
   * consumer with the value.<p>
   *
   * @return an {@link EventStream} which emits the same values as this stream and calls the given {@code sideEffect}
   *         consumer with each value, never null
   */
  EventStream<T> peek(Consumer<? super T> sideEffect);

  /**
   * Returns an {@link EventStream}, using this stream as its source,
   * which emits values converted by the given mapper function.<p>
   *
   * If the mapper maps the event to {@code null}, the event is discarded.
   *
   * @param <U> the type of values the new stream emits
   * @param mapper a {@link Function} which converts a source value to a new value to emit, cannot be null
   * @return an {@link EventStream} which emits values converted by the given mapper function, never null
   */
  <U> EventStream<U> map(Function<? super T, ? extends U> mapper);

  /**
   * Returns a {@link EventStream} which, each time this stream emits a value,
   * obtains a new stream supplied by mapper and emits its values instead. If
   * the mapper function returns {@code null} an empty stream will be used
   * instead.<p>
   *
   * Note: EventStreams donot emit values eagerly, so when this stream
   * emits a value, the stream being tracked changes but an event will
   * only be emitted when that stream emits an event after tracking started.
   * See also {@link ValueStream#flatMap(Function)}.<p>
   *
   * An example where the source stream flat maps to event stream A or B,
   * note especially that a change of stream does not necessarily result in
   * an emission:
   * <pre>
   *            Time ---&gt;
   *       Source :--A---A--B--B--A--A--BA--B---------&gt;
   *  Events of A :-3-4-7---8--7----4-----34---5--56--&gt;
   *  Events of B :-1---6---6----5---8----9---2---5---&gt;
   *     Tracking :--AAAAAAABBBBBBAAAAAABAAABBBBBBBBB-&gt;
   *        Emits :---4-7---6----5--4-----34--2---5---&gt;
   * </pre>
   *
   * @param mapper a {@link Function} which returns an alternative stream for each event this stream emits, cannot be null
   * @return a {@link EventStream} which obtains a new stream supplied by mapper and emits its events instead, never null
   */
  <U> EventStream<U> flatMap(Function<? super T, ? extends EventStream<? extends U>> mapper);

  /**
   * Returns a {@link ValueStream}, using this stream as its source,
   * which emits the given value as its default value for new subscribers.
   *
   * @param value a value to emit as default value for new subscribers
   * @return a {@link ValueStream} which emits the given value as its default value, never null
   */
  default ValueStream<T> withDefault(T value) {
    return withDefaultGet(() -> value);
  }

  /**
   * Returns a {@link ValueStream}, using this stream as its source,
   * which emits the value generated by the given defaultValueSupplier
   * as its default value for new subscribers.
   *
   * @param defaultValueSupplier a {@link Supplier} which supplies the value to emit as default value for new subscribers
   * @return a {@link ValueStream} which uses the given defaultValueSupplier to provide its default value, never null
   */
  ValueStream<T> withDefaultGet(Supplier<? extends T> defaultValueSupplier);
}
