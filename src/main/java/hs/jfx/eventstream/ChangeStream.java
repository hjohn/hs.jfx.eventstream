package hs.jfx.eventstream;

import hs.jfx.eventstream.impl.DefaultStream;
import hs.jfx.eventstream.impl.FilterStream;
import hs.jfx.eventstream.impl.FlatMapStream;
import hs.jfx.eventstream.impl.MapStream;
import hs.jfx.eventstream.impl.PeekStream;
import hs.jfx.eventstream.impl.TransactionalStream;
import hs.jfx.eventstream.util.StreamUtil;

import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

import javafx.beans.value.ObservableValue;

/**
 * A sequence of values supporting aggregate operations. The values
 * emitted from this stream are always a direct result from a change
 * occuring in the source of this stream.<p>
 *
 * Subscribers will receive changes only when they occur. If no changes
 * occur it is therefore possible that a subscription will never receive
 * a change.<p>
 *
 * The operations offered by this stream are null safe. Operations
 * accepting a {@link Function} or {@link Consumer} will never be given
 * a <code>null</code> value as input unless otherwise specified.
 *
 * @param <T> the type of values the stream emits
 */
public interface ChangeStream<T> extends ObservableStream<T> {

  /**
   * Returns a {@link ChangeStream}, using this stream as its source,
   * which only emits values matching the given predicate.
   *
   * @param predicate a {@link Predicate} which values must match to be emitted, cannot be null
   * @return a {@link ChangeStream} which only emits values matching the given predicate, never null
   */
  default ChangeStream<T> filter(Predicate<T> predicate) {
    return new FilterStream<>(this, predicate);
  }

  // TODO offer toBinding here as well, but with the default?
  // TODO better name?  whenEmpty?  whenLazy?  toValueStream?  eager?

  /**
   * Returns a {@link ValueStream}, using this stream as its source,
   * which emits the given value as its default value for new subscribers.
   *
   * @param value a value to emit as default value for new subscribers
   * @return a {@link ValueStream} which emits the given value as its default value, never null
   */
  default ValueStream<T> withDefault(T value) {
    return withDefaultGet(() -> value);
  }

  /**
   * Returns a {@link ValueStream}, using this stream as its source,
   * which emits the value generated by the given defaultValueSupplier
   * as its default value for new subscribers.
   *
   * @param defaultValueSupplier a {@link Supplier} which supplies the value to emit as default value for new subscribers
   * @return a {@link ValueStream} which uses the given defaultValueSupplier to provide its default value, never null
   */
  default ValueStream<T> withDefaultGet(Supplier<T> defaultValueSupplier) {
    return new DefaultStream<>(this, defaultValueSupplier);
  }

  /**
   * Returns a {@link ChangeStream}, using this stream as its source,
   * which emits values converted by the given mapper function.
   *
   * @param <U> the type of values the new stream emits
   * @param mapper a {@link Function} which converts a source value to a new value to emit, cannot be null
   * @return a {@link ChangeStream} which emits values converted by the given mapper function, never null
   */
  default <U> ChangeStream<U> map(Function<? super T, ? extends U> mapper) {
    return new MapStream.Change<>(this, mapper, StreamUtil.nullSupplier());
  }

  // let docs reflect that a flatmap on a change stream means changing of streams, but not emitting current value of destination stream!

  /**
   * Returns a {@link ChangeStream}, using this stream as its source,
   * which obtains a new stream supplied by mapper, each time this
   * stream emits a value, and keeps emitting its values.
   *
   * @param mapper a {@link Function} which returns an alternative stream for each value this stream emits, cannot be null
   * @return a {@link ChangeStream} which obtains a new stream supplied by mapper and keeps emitting its values, never null
   */
  default <U> ChangeStream<U> flatMap(Function<? super T, ? extends ChangeStream<? extends U>> mapper) {
    return new FlatMapStream.Change<>(this, mapper, Changes::empty);
  }

  default ChangeStream<T> peek(Consumer<? super T> sideEffect) {
    return new PeekStream.Change<>(this, sideEffect);
  }

  // In case the value supplied by this stream is null, feed values from supplied stream
  /**
   * Returns a {@link ChangeStream}, using this stream as its source,
   * which emits values from this stream unless the value was
   * <code>null</code> in which case it emits values from the supplied stream
   * until a new value is emitted from this stream.
   *
   * @param supplier a {@link Supplier} supplying an alternative stream when this stream emitted <code>null</code>, cannot be null
   * @return a {@link ChangeStream} which emits values from this stream unless the value was <code>null</code>
   *         in which case it emits values from the supplied stream, never null
   */
  default ChangeStream<T> or(Supplier<? extends ChangeStream<? extends T>> supplier) {
    Objects.requireNonNull(supplier);

    return new FlatMapStream.Change<>(this, v -> this, supplier);
  }

  /**
   * Returns a {@link ChangeStream}, using this stream as its source,
   * which emits values from this stream but with <code>null</code>s
   * replaced with the given value.
   *
   * @param value a value to emit instead of <code>null</code>
   * @return a {@link ChangeStream} with <code>null</code>s replaced with the given value, never null
   */
  default ChangeStream<T> orElse(T value) {
    return orElseGet(() -> value);
  }

  /**
   * Returns a {@link ChangeStream}, using this stream as its source,
   * which emits the same values as its source but with <code>null</code>s
   * replaced with the value supplied by the given {@link Supplier}.
   *
   * @param valueSupplier a {@link Supplier} which supplies the value to emit instead of <code>null</code>
   * @return a {@link ChangeStream} with <code>null</code>s replaced with the value supplied by the given {@link Supplier}, never null
   */
  default ChangeStream<T> orElseGet(Supplier<T> valueSupplier) {
    return new MapStream.Change<>(this, Function.identity(), valueSupplier);
  }

  /**
   * Returns a {@link ChangeStream}, using this stream as its source,
   * which only subscribes to its source stream when the given {@link ObservableValue}
   * is true.<p>
   *
   * Although similar to {@link #filter(Predicate)}, the condition is not
   * based on the actual values emitted by the source stream, and as such
   * the subscription to the source stream can be cancelled when the
   * condition evaluates to false.<p>
   *
   * @param condition a boolean {@link ObservableValue}, cannot be null
   * @return a {@link ChangeStream} which only subscribes to its source stream when the given {@link ObservableValue} is true, never null
   */
  default ChangeStream<T> conditionOn(ObservableValue<Boolean> condition) {
    return Values.of(condition).flatMapToChange(c -> c ? this : Changes.empty());
  }

  default ChangeStream<T> transactional() {
    return new TransactionalStream.Change<>(this);
  }

//  @Override
//  default T getCurrentValue() {
//    return BaseStream.nullEvent();
//  }
}
